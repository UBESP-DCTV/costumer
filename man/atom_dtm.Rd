% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/atom_dtm.R
\name{atom_dtm}
\alias{atom_dtm}
\alias{atom_dtm.list}
\alias{atom_dtm.VCorpus}
\alias{atom_dtm.character}
\alias{atom_dtm.default}
\title{Create a dtm from a corpus (tf weights)}
\usage{
atom_dtm(corpus, step = 500L, parallel = FALSE, ...,
  ncores = parallel::detectCores() - 1)

\method{atom_dtm}{list}(corpus, step = 500L, parallel = FALSE, ...,
  ncores = parallel::detectCores() - 1)

\method{atom_dtm}{VCorpus}(corpus, step = 500L, parallel = FALSE, ...,
  ncores = parallel::detectCores() - 1)

\method{atom_dtm}{character}(corpus, step = 500L, parallel = FALSE, ...,
  ncores = parallel::detectCores() - 1, docs_or_tokens = c("docs",
  "tokens"))

\method{atom_dtm}{default}(corpus, step = 500L, parallel = FALSE, ...,
  ncores = parallel::detectCores() - 1)
}
\arguments{
\item{corpus}{(list) of documents, or a list of character vectors, each
element reporting tokens from a document}

\item{step}{(num) integer value (default is 500L) used to broken the
procedure in parts of at maximum \code{step} documents each one.
This is to help to don't overflow the RAM.}

\item{parallel}{(lgl) if \code{TRUE} (default is \code{FALSE}) run parallel
computations using \code{\link[parallel]{makePSOCKcluster}}
backend with max - 1 core.}

\item{...}{further option passed to the function}

\item{ncores}{(int) number of core to use in the parallel computation
(default is number of machine cores minus one)}

\item{docs_or_tokens}{(chr) if \code{docs} (default) means that the
sequencies of elements of the character vector represent a document
each one, if \code{tokens} means that they represents the sequencies
of tokens of one single documents}
}
\value{
a multiclass \code{\link[tm]{DocumentTermMatrix}} and
        \code{\link[slam]{simple_triplet_matrix}} object weigthed with simple
        term frequencies, rappresenting a document-term matrix in which each
        row represent a document, each columns a term (or token) and the
        content the simple frequencies of the terms in the document.
}
\description{
\code{atom_dtm} take a corpora, tokenized or not, and create the
corresponding \code{\link[tm]{DocumentTermMatrix}} (DTM) stored as sparse
\code{\link[slam]{simple_triplet_matrix}} (see Details).
}
\details{
The algrithm of the simple triplet matrix considers three indeces \code{i},
\code{j}, \code{v}, in which the indeces \code{i}, \code{j} represent
respectively the row (document) and the column (term/token) coordinate of an
entry \code{v} rapresent its weight (commonly the frequency).

Moreover, for compatibility reasons (with some machine learning R
implementation of algorithms which use different convention for the
representation of sparse matrices), the indeces are ordered with priority
\code{i}, \code{j}.
}
\examples{
data(liu_4h28)
corpus <- data2corpus(liu_4h28)
atom_dtm(corpus)
atom_dtm(c('one', 'two', 'one two'))             # three documents, two token
atom_dtm(c('one', 'two', 'one two'), docs_or_tokens = 'tokens')    # one docs

\dontrun{
  atom_dtm(corpus, parallel = TRUE)                    # parallel computation
  atom_dtm(c(1, 2, 3))                                 # error
}
}
